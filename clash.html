<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Analyseur de Bases CoC - Exportable</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            padding: 15px;
            background-color: #e8f0f5;
        }

        .column {
            flex: 1;
            min-width: 450px;
            background-color: #fff;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
        }

        /* Container for layered canvases */
        #canvasContainer {
            position: relative; /* Crucial for absolute positioning inside */
            width: 100%;
            max-width: 700px;
            height: 500px; /* Match canvas height */
            margin-bottom: 15px;
            border: 1px solid #ccc;
            background-color: #ffffff; /* Fallback background */
            overflow: hidden;
        }

        /* Layered Canvases */
        #backgroundCanvas, #drawingCanvas {
            display: block;
            position: absolute; /* Stack them */
            top: 0;
            left: 0;
            width: 100%; /* Fit container */
            height: 100%; /* Fit container */
        }

        #backgroundCanvas {
            z-index: 1; /* Background layer */
            background-color: #ffffff; /* Ensure it has a background */
        }

        #drawingCanvas {
            z-index: 2; /* Drawing layer on top */
            background-color: transparent; /* MUST be transparent */
            cursor: crosshair; /* Cursor on the top layer */
        }


        .controls-section {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid #eee;
        }
        .controls-section:last-child {
            border-bottom: none;
        }

        .controls-section h3 {
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 1.1em;
            color: #333;
        }

        button, select, input[type="text"], input[type="file"] {
            padding: 8px 12px;
            margin: 5px 5px 5px 0;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 0.9em;
            cursor: pointer;
            background-color: #f8f8f8;
            transition: background-color 0.2s ease;
            vertical-align: middle;
        }
        input[type="file"] { cursor: pointer; }
        button:hover, select:hover { background-color: #e9e9e9; }
        button:active { background-color: #dcdcdc; }

        .tool-btn.active, .color-btn.active {
            border-width: 2px;
            border-color: #007bff;
            box-shadow: 0 0 5px rgba(0, 123, 255, 0.5);
            background-color: #e0efff;
        }

        .color-btn { min-width: 60px; text-align: center;}
        .color-btn[data-color="red"] { background-color: #e74c3c; color: white; }
        .color-btn[data-color="blue"] { background-color: #3498db; color: white; }
        .color-btn[data-color="green"] { background-color: #2ecc71; color: white; }
        .color-btn[data-color="black"] { background-color: #34495e; color: white; }
        .color-btn[data-color="yellow"] { background-color: #f1c40f; color: black; }
        .color-btn[data-color="purple"] { background-color: #9b59b6; color: white; }
        .color-btn[data-color="white"] { background-color: #ecf0f1; color: black; }

        #analysisNotes {
            width: 95%;
            height: 150px;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 10px;
            font-family: monospace;
            margin-top: 5px;
            resize: vertical;
        }

        #savedAnalysesDropdown { width: calc(100% - 24px); margin-bottom: 10px; }
        label { display: block; margin-bottom: 5px; font-weight: bold; color: #555; }
        #analysisNameInput { width: calc(100% - 130px); margin-right: 5px; }
        .button-group { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
        .file-input-label { display: inline-block; padding: 8px 12px; background-color: #5cb85c; color: white; border-radius: 4px; cursor: pointer; margin: 5px 0; }
        .file-input-label:hover { background-color: #4cae4c; }
        #bgImageUpload { display: none; }
        #fileNameDisplay { margin-left: 10px; font-style: italic; color: #777; font-size: 0.9em; }
        .tooltip { font-size: 0.85em; color: #666; margin-left: 5px; }

    </style>
</head>
<body>

    <div class="column">
        <h2>Zone de Dessin et Outils</h2>

        <div class="controls-section">
            <h3>Charger Image de Fond</h3>
             <div class="button-group">
                <label for="bgImageUpload" class="file-input-label">üñºÔ∏è Choisir une image</label>
                <input type="file" id="bgImageUpload" accept="image/*">
                <span id="fileNameDisplay">Aucun fichier choisi</span>
                <button id="removeBgButton" style="background-color: #d9534f; color: white;">‚ùå Supprimer Fond</button>
            </div>
        </div>

        <!-- Canvas Container -->
        <div id="canvasContainer">
             <canvas id="backgroundCanvas">Fond</canvas>
             <canvas id="drawingCanvas">Dessin</canvas>
        </div>
        <!-- End Canvas Container -->

        <div class="controls-section">
            <h3>Outils de Dessin</h3>
             <div class="button-group">
                <button id="toolPencil" class="tool-btn active" data-tool="pencil">‚úèÔ∏è Crayon/Fl√®che</button>
                <button id="toolText" class="tool-btn" data-tool="text"> T Texte</button>
                <button id="toolEraser" class="tool-btn" data-tool="eraser">üßº Gomme</button>
                <button id="clearCanvasButton">üóëÔ∏è Effacer Dessins</button>
            </div>
        </div>

        <div class="controls-section">
             <h3>Marqueurs & Zones <span class="tooltip">(Clic ou Clic & Glisser pour sorts)</span></h3>
             <div class="button-group">
                 <button class="tool-btn marker-btn" data-tool="marker" data-marker="troop_ground">üë§ Terreste</button>
                 <button class="tool-btn marker-btn" data-tool="marker" data-marker="troop_air">üêâ A√©rien</button>
                 <button class="tool-btn marker-btn" data-tool="marker" data-marker="hero">üëë H√©ros</button>
                 <button class="tool-btn marker-btn" data-tool="marker" data-marker="spell_heal" data-resizable="true">‚ú® Soin</button>
                 <button class="tool-btn marker-btn" data-tool="marker" data-marker="spell_rage" data-resizable="true">üü£ Rage</button>
                 <button class="tool-btn marker-btn" data-tool="marker" data-marker="spell_area" data-resizable="true">‚≠ï Zone Sort</button>
                 <button class="tool-btn marker-btn" data-tool="marker" data-marker="target">üéØ Cible</button>
             </div>
         </div>

        <div class="controls-section">
            <h3>Couleurs <span class="tooltip">(Crayon, Texte, Marqueurs)</span></h3>
             <div class="button-group">
                <button class="color-btn active" data-color="red">Rouge</button>
                <button class="color-btn" data-color="blue">Bleu</button>
                <button class="color-btn" data-color="green">Vert</button>
                <button class="color-btn" data-color="black">Noir</button>
                <button class="color-btn" data-color="yellow">Jaune</button>
                <button class="color-btn" data-color="purple">Violet</button>
                <button class="color-btn" data-color="white">Blanc</button>
            </div>
        </div>
    </div>

    <div class="column">
        <h2>Analyse & Sauvegarde</h2>

        <div class="controls-section">
            <label for="analysisNotes">Commentaires / Composition d'arm√©e :</label>
            <textarea id="analysisNotes" placeholder="Entrez vos notes ici..."></textarea>
        </div>

        <div class="controls-section">
            <h3>Sauvegarder l'Analyse</h3>
             <div class="button-group">
                 <input type="text" id="analysisNameInput" placeholder="Nom de l'analyse" required>
                 <button id="saveAnalysisButton">üíæ Sauvegarder</button>
             </div>
        </div>

        <div class="controls-section">
            <h3>Charger / Supprimer une Analyse</h3>
            <label for="savedAnalysesDropdown">Analyses Sauvegard√©es :</label>
            <select id="savedAnalysesDropdown">
                <option value="">-- S√©lectionnez --</option>
            </select>
             <div class="button-group" style="margin-top: 10px;">
                <button id="deleteAnalysisButton">‚ùå Supprimer S√©lection</button>
            </div>
        </div>

         <div class="controls-section">
            <h3>Exporter</h3>
             <div class="button-group">
                <button id="exportAnalysisButton">üì§ Exporter en PNG</button>
             </div>
        </div>

    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Elements ---
            const canvasContainer = document.getElementById('canvasContainer');
            const backgroundCanvas = document.getElementById('backgroundCanvas'); // Background Layer
            const drawingCanvas = document.getElementById('drawingCanvas');     // Drawing Layer
            const bgCtx = backgroundCanvas.getContext('2d');
            const drawCtx = drawingCanvas.getContext('2d'); // DRAW ON THIS context

            const analysisNotes = document.getElementById('analysisNotes');
            const saveAnalysisButton = document.getElementById('saveAnalysisButton');
            const analysisNameInput = document.getElementById('analysisNameInput');
            const savedAnalysesDropdown = document.getElementById('savedAnalysesDropdown');
            const deleteAnalysisButton = document.getElementById('deleteAnalysisButton');
            const clearCanvasButton = document.getElementById('clearCanvasButton');
            const bgImageUpload = document.getElementById('bgImageUpload');
            const removeBgButton = document.getElementById('removeBgButton');
            const fileNameDisplay = document.getElementById('fileNameDisplay');
            const toolButtons = document.querySelectorAll('.tool-btn');
            const colorButtons = document.querySelectorAll('.color-btn');
            const exportAnalysisButton = document.getElementById('exportAnalysisButton');

            // --- Constants ---
            const STORAGE_KEY = 'clashAnalyses_v4'; // Incremented version for new structure
            const ERASER_WIDTH = 25;
            const PENCIL_WIDTH = 3;
            const TEXT_FONT = 'bold 16px Arial';
            const MARKER_SIZE = 20;
            const DRAGON_FONT_SIZE = 24;
            const STICKMAN_LINE_WIDTH = 2;
            const SPELL_AREA_ALPHA = 0.4;
            const DEFAULT_SPELL_RADIUS = 35;
            const EXPORT_TEXT_PADDING = 15;
            const EXPORT_TEXT_LINE_HEIGHT = 20;
            const EXPORT_TEXT_FONT = '14px monospace';
            const EXPORT_BG_COLOR = '#FFFFFF';

            // --- State Variables ---
            let isDrawing = false;
            let isResizingSpell = false;
            let lastX = 0, lastY = 0;
            let spellCenterX = 0, spellCenterY = 0;
            let spellCurrentRadius = 0;
            let canvasStateBeforeResize = null; // Stores ImageData of drawingCanvas

            let currentTool = 'pencil';
            let currentMarkerType = '';
            let isMarkerResizable = false;
            let currentColor = 'red';

            let backgroundImage = null;
            let backgroundImageDataUrl = null; // Only store for saving/loading

            // --- Canvas Setup & Drawing ---
            function resizeCanvas() {
                // Set both canvases to the container's size
                const width = canvasContainer.offsetWidth;
                const height = canvasContainer.offsetHeight;

                backgroundCanvas.width = width;
                backgroundCanvas.height = height;
                drawingCanvas.width = width;
                drawingCanvas.height = height;

                console.log(`Canvases resized to: ${width}x${height}`);
                // Redraw background and restore overlay if possible (e.g., from saved state)
                redrawBackground();
                // Note: Drawings on drawingCanvas might be lost on resize unless loaded/redrawn
            }

             function drawBackground() {
                 // Clear background canvas first
                 bgCtx.clearRect(0, 0, backgroundCanvas.width, backgroundCanvas.height);

                 if (backgroundImage) {
                     const hRatio = backgroundCanvas.width / backgroundImage.width;
                     const vRatio = backgroundCanvas.height / backgroundImage.height;
                     const ratio = Math.min(hRatio, vRatio);
                     const centerShift_x = (backgroundCanvas.width - backgroundImage.width * ratio) / 2;
                     const centerShift_y = (backgroundCanvas.height - backgroundImage.height * ratio) / 2;
                     bgCtx.drawImage(backgroundImage, 0, 0, backgroundImage.width, backgroundImage.height,
                                   centerShift_x, centerShift_y, backgroundImage.width * ratio, backgroundImage.height * ratio);
                     console.log("Background drawn on bgCanvas");
                 } else {
                     // Draw default white background if no image
                     bgCtx.fillStyle = '#FFFFFF';
                     bgCtx.fillRect(0, 0, backgroundCanvas.width, backgroundCanvas.height);
                     console.log("Default background drawn on bgCanvas");
                 }
             }

             // Redraws background and overlay (e.g., after load)
             function redrawAll(bgDataUrl, overlayDataUrl) {
                 // Load background image first (async)
                 backgroundImage = null; // Reset current bg
                 backgroundImageDataUrl = bgDataUrl; // Store for potential resave

                 const loadOverlay = () => {
                     clearDrawingCanvas(); // Clear previous drawings first
                     if (overlayDataUrl) {
                         const img = new Image();
                         img.onload = () => { drawCtx.drawImage(img, 0, 0); };
                         img.onerror = () => console.error("Error loading overlay image for redraw.");
                         img.src = overlayDataUrl;
                     }
                 };

                 if (bgDataUrl) {
                     const bgImg = new Image();
                     bgImg.onload = () => {
                         backgroundImage = bgImg; // Set the loaded image object
                         drawBackground();      // Draw it on the background canvas
                         loadOverlay();         // Then load the overlay on the drawing canvas
                     };
                     bgImg.onerror = () => {
                         console.error("Error loading background image for redraw.");
                         backgroundImage = null; // Reset on error
                         drawBackground();      // Draw default white background
                         loadOverlay();         // Still attempt to load overlay
                     };
                     bgImg.src = bgDataUrl;
                 } else {
                     // No background data, draw default and load overlay
                     drawBackground();
                     loadOverlay();
                 }
             }

             // Clears only the drawing layer
             function clearDrawingCanvas() {
                 drawCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                 console.log("Drawing canvas cleared");
             }

             // --- Tool Implementation (Draw on drawCtx) ---
             function drawLine(x0, y0, x1, y1) {
                 drawCtx.beginPath();
                 drawCtx.moveTo(x0, y0);
                 drawCtx.lineTo(x1, y1);
                 drawCtx.strokeStyle = currentColor;
                 drawCtx.lineWidth = PENCIL_WIDTH; // Use pencil width
                 drawCtx.lineCap = 'round';
                 drawCtx.lineJoin = 'round';
                 drawCtx.globalCompositeOperation = 'source-over'; // Normal drawing
                 drawCtx.stroke();
             }

             function eraseLine(x0, y0, x1, y1) {
                 drawCtx.beginPath();
                 drawCtx.moveTo(x0, y0);
                 drawCtx.lineTo(x1, y1);
                 // Color doesn't matter for destination-out, but width does
                 drawCtx.lineWidth = ERASER_WIDTH;
                 drawCtx.lineCap = 'round';
                 drawCtx.lineJoin = 'round';
                 drawCtx.globalCompositeOperation = 'destination-out'; // Erase
                 drawCtx.stroke();
                 // IMPORTANT: Reset composite operation immediately after erasing stroke
                 drawCtx.globalCompositeOperation = 'source-over';
             }

             function addText(x, y) {
                 const text = prompt("Entrez le texte √† ajouter :");
                 if (text) {
                     drawCtx.fillStyle = currentColor;
                     drawCtx.font = TEXT_FONT;
                     drawCtx.textAlign = 'center';
                     drawCtx.textBaseline = 'middle';
                     drawCtx.globalCompositeOperation = 'source-over';
                     drawCtx.fillText(text, x, y);
                 }
             }

             function placeFixedMarker(x, y) {
                 drawCtx.fillStyle = currentColor;
                 drawCtx.strokeStyle = 'black';
                 drawCtx.lineWidth = 1;
                 drawCtx.globalCompositeOperation = 'source-over';

                 switch (currentMarkerType) {
                     case 'troop_ground': drawStickman(drawCtx, x, y); break;
                     case 'troop_air': drawDragon(drawCtx, x, y); break;
                     case 'hero': drawStar(drawCtx, x, y, 5, MARKER_SIZE, MARKER_SIZE / 2); break;
                     case 'target': drawCrosshair(drawCtx, x, y); break;
                 }
             }

             function drawSpellCircle(context, cx, cy, radius, type, alpha = SPELL_AREA_ALPHA) {
                 context.beginPath();
                 context.globalCompositeOperation = 'source-over';
                 let fillColor;
                 let baseColor = currentColor; // Default to selected color for 'area'

                 switch (type) {
                     case 'spell_heal': baseColor = 'yellow'; alpha += 0.2; break; // More visible
                     case 'spell_rage': baseColor = 'purple'; break;
                 }

                 fillColor = hexToRgba(baseColor, Math.min(1, alpha)); // Ensure alpha <= 1
                 context.fillStyle = fillColor;
                 context.arc(cx, cy, Math.max(1, radius), 0, Math.PI * 2);
                 context.fill();
             }


             // --- Specific Marker Drawing Functions (now accept context) ---
             function drawStickman(ctxTarget, x, y) {
                 ctxTarget.strokeStyle = currentColor;
                 ctxTarget.lineWidth = STICKMAN_LINE_WIDTH;
                 const headRadius = MARKER_SIZE * 0.2;
                 const bodyLength = MARKER_SIZE * 0.5;
                 const limbLength = MARKER_SIZE * 0.4;
                 // Draw commands... (same as before but use ctxTarget)
                 ctxTarget.beginPath(); ctxTarget.arc(x, y - bodyLength / 2 - headRadius, headRadius, 0, Math.PI * 2); ctxTarget.stroke(); // Head
                 ctxTarget.beginPath(); ctxTarget.moveTo(x, y - bodyLength / 2); ctxTarget.lineTo(x, y + bodyLength / 2); // Body
                 ctxTarget.moveTo(x - limbLength, y - bodyLength * 0.1); ctxTarget.lineTo(x, y - bodyLength / 2); ctxTarget.lineTo(x + limbLength, y - bodyLength * 0.1); // Arms
                 ctxTarget.moveTo(x - limbLength, y + bodyLength / 2 + limbLength); ctxTarget.lineTo(x, y + bodyLength / 2); ctxTarget.lineTo(x + limbLength, y + bodyLength / 2 + limbLength); // Legs
                 ctxTarget.stroke();
             }
             function drawDragon(ctxTarget, x, y) {
                 ctxTarget.font = `${DRAGON_FONT_SIZE}px Arial`;
                 ctxTarget.fillStyle = currentColor; // Set color just in case
                 ctxTarget.textAlign = 'center'; ctxTarget.textBaseline = 'middle';
                 ctxTarget.fillText('üêâ', x, y);
             }
             function drawStar(ctxTarget, cx, cy, spikes, outerRadius, innerRadius) {
                 // Draw commands... (same as before but use ctxTarget and fill at the end)
                  let rot = Math.PI / 2 * 3; let x = cx; let y = cy; let step = Math.PI / spikes;
                  ctxTarget.beginPath(); ctxTarget.moveTo(cx, cy - outerRadius);
                  for (let i = 0; i < spikes; i++) { x = cx + Math.cos(rot) * outerRadius; y = cy + Math.sin(rot) * outerRadius; ctxTarget.lineTo(x, y); rot += step; x = cx + Math.cos(rot) * innerRadius; y = cy + Math.sin(rot) * innerRadius; ctxTarget.lineTo(x, y); rot += step; }
                  ctxTarget.lineTo(cx, cy - outerRadius); ctxTarget.closePath();
                  ctxTarget.fillStyle = currentColor; // Apply fill color
                  ctxTarget.fill();
             }
             function drawCrosshair(ctxTarget, x, y) {
                 ctxTarget.strokeStyle = currentColor; ctxTarget.lineWidth = 2;
                 ctxTarget.beginPath();
                 ctxTarget.moveTo(x - MARKER_SIZE / 1.5, y); ctxTarget.lineTo(x + MARKER_SIZE / 1.5, y);
                 ctxTarget.moveTo(x, y - MARKER_SIZE / 1.5); ctxTarget.lineTo(x, y + MARKER_SIZE / 1.5);
                 ctxTarget.stroke();
             }

            // --- Text Wrapping Function for Export ---
             function wrapText(context, text, x, y, maxWidth, lineHeight) {
                 const words = text.split(' ');
                 let line = '';
                 let currentY = y;

                 context.textBaseline = 'top'; // Align text from the top for wrapping

                 for (let n = 0; n < words.length; n++) {
                     const testLine = line + words[n] + ' ';
                     const metrics = context.measureText(testLine);
                     const testWidth = metrics.width;
                     if (testWidth > maxWidth && n > 0) {
                         context.fillText(line, x, currentY);
                         line = words[n] + ' ';
                         currentY += lineHeight;
                     } else {
                         line = testLine;
                     }
                 }
                 context.fillText(line, x, currentY); // Draw the last line
                 return currentY + lineHeight; // Return the Y position after the last line
             }

             // --- Utility Functions ---
             function hexToRgba(hex, alpha) { /* ... (same as before) ... */
                if (!hex.startsWith('#')) { const colorMap = { red: '#FF0000', yellow: '#FFFF00', green: '#008000', blue: '#0000FF', purple: '#800080', black: '#000000', white: '#FFFFFF' }; hex = colorMap[hex.toLowerCase()] || '#000000'; }
                hex = hex.replace('#', ''); if (hex.length === 3) hex = hex.split('').map(c => c + c).join(''); if (hex.length !== 6) return `rgba(0,0,0,${alpha})`;
                const r = parseInt(hex.substring(0, 2), 16); const g = parseInt(hex.substring(2, 4), 16); const b = parseInt(hex.substring(4, 6), 16); return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            }
            function getMousePos(e) { const rect = drawingCanvas.getBoundingClientRect(); return { x: e.clientX - rect.left, y: e.clientY - rect.top }; }

             // --- Event Handlers ---
             function handleMouseDown(e) {
                 const { x, y } = getMousePos(e);
                 if (currentTool === 'marker' && isMarkerResizable) {
                     isResizingSpell = true; isDrawing = false;
                     spellCenterX = x; spellCenterY = y; spellCurrentRadius = 0;
                     try {
                         // Save state of DRAWING canvas only
                         canvasStateBeforeResize = drawCtx.getImageData(0, 0, drawingCanvas.width, drawingCanvas.height);
                     } catch(err) { console.error("Error getting ImageData:", err); canvasStateBeforeResize = null; }
                     drawingCanvas.style.cursor = 'grabbing';
                 } else if (currentTool === 'pencil' || currentTool === 'eraser') {
                     isDrawing = true; isResizingSpell = false;
                     [lastX, lastY] = [x, y];
                     // Draw initial point for eraser
                     if (currentTool === 'eraser') {
                         eraseLine(x,y,x,y);
                     }
                 } else { isDrawing = false; isResizingSpell = false; }
             }

             function handleMouseMove(e) {
                 const { x, y } = getMousePos(e);
                 if (isResizingSpell) {
                     if (canvasStateBeforeResize) { // Restore drawing canvas state before drawing preview
                         drawCtx.putImageData(canvasStateBeforeResize, 0, 0);
                     } else { clearDrawingCanvas(); /* Less ideal fallback */ }
                     const dx = x - spellCenterX; const dy = y - spellCenterY;
                     spellCurrentRadius = Math.sqrt(dx * dx + dy * dy);
                     // Draw preview circle directly on drawing canvas
                     drawSpellCircle(drawCtx, spellCenterX, spellCenterY, spellCurrentRadius, currentMarkerType);
                 } else if (isDrawing) {
                     if (currentTool === 'pencil') { drawLine(lastX, lastY, x, y); }
                     else if (currentTool === 'eraser') { eraseLine(lastX, lastY, x, y); }
                     [lastX, lastY] = [x, y];
                 }
             }

             function handleMouseUp(e) {
                 const { x, y } = getMousePos(e);
                 if (isResizingSpell) {
                     if (canvasStateBeforeResize) { // Restore before drawing final spell
                         drawCtx.putImageData(canvasStateBeforeResize, 0, 0);
                     }
                     const dx = x - spellCenterX; const dy = y - spellCenterY;
                     const finalRadius = Math.max(5, Math.sqrt(dx * dx + dy * dy));
                     // Draw final spell circle permanently on drawing canvas
                     drawSpellCircle(drawCtx, spellCenterX, spellCenterY, finalRadius, currentMarkerType);
                     isResizingSpell = false; canvasStateBeforeResize = null;
                     drawingCanvas.style.cursor = 'crosshair'; // Reset cursor
                 } else if (!isDrawing && currentTool === 'text') { addText(x, y); }
                 else if (!isDrawing && currentTool === 'marker' && !isMarkerResizable) { placeFixedMarker(x, y); }
                 isDrawing = false; // Stop line drawing if it was active
                 // Ensure composite operation is reset after any mouseup (belt-and-suspenders)
                  drawCtx.globalCompositeOperation = 'source-over';
             }

            // --- Local Storage & UI --- (Save/Load needs to handle two layers indirectly)
            function saveAnalysis() {
                 const name = analysisNameInput.value.trim();
                 if (!name) { alert("Nom requis."); analysisNameInput.focus(); return; }

                 // Capture the state of the *drawing* canvas only
                 const canvasOverlayDataUrl = drawingCanvas.toDataURL();
                 const notes = analysisNotes.value;
                 const newAnalysis = {
                     name,
                     backgroundDataUrl: backgroundImageDataUrl, // Save the original BG dataURL
                     canvasOverlayDataUrl: canvasOverlayDataUrl, // Save the drawing layer dataURL
                     notes,
                     // Store canvas dimensions at time of save
                     canvasWidth: drawingCanvas.width,
                     canvasHeight: drawingCanvas.height
                 };

                 let analyses = getSavedAnalyses();
                 const existingIndex = analyses.findIndex(a => a.name === name);
                 if (existingIndex > -1) {
                     if (confirm(`"${name}" existe d√©j√†. √âcraser ?`)) { analyses[existingIndex] = newAnalysis; }
                     else { return; }
                 } else { analyses.push(newAnalysis); }

                 saveAnalyses(analyses);
                 populateDropdown();
                 analysisNameInput.value = ''; savedAnalysesDropdown.value = name;
                 deleteAnalysisButton.disabled = false; alert(`Analyse "${name}" sauvegard√©e !`);
             }

             function loadAnalysis() {
                 const selectedName = savedAnalysesDropdown.value;
                 deleteAnalysisButton.disabled = selectedName === "";

                 if (!selectedName) { /* Reset view */
                     analysisNotes.value = ''; analysisNameInput.value = '';
                     backgroundImage = null; backgroundImageDataUrl = null;
                     fileNameDisplay.textContent = "Aucun fichier choisi";
                     resizeCanvas(); // Resize clears canvases, redrawBackground draws default
                     clearDrawingCanvas(); // Ensure drawing layer is clear
                     return;
                 }

                 const analyses = getSavedAnalyses();
                 const analysisToLoad = analyses.find(a => a.name === selectedName);

                 if (analysisToLoad) {
                     analysisNotes.value = analysisToLoad.notes;
                     analysisNameInput.value = analysisToLoad.name;

                     // Restore canvas size *before* drawing
                     const savedWidth = analysisToLoad.canvasWidth || canvasContainer.offsetWidth;
                     const savedHeight = analysisToLoad.canvasHeight || canvasContainer.offsetHeight;
                     backgroundCanvas.width = drawingCanvas.width = savedWidth;
                     backgroundCanvas.height = drawingCanvas.height = savedHeight;

                      // Use redrawAll to handle async loading of images
                     redrawAll(analysisToLoad.backgroundDataUrl, analysisToLoad.canvasOverlayDataUrl);

                      // Update filename display based on loaded data
                      fileNameDisplay.textContent = analysisToLoad.backgroundDataUrl ? "Fond charg√© (sauvegarde)" : "Aucun fond sauvegard√©";

                 } else { alert("Erreur: Analyse non trouv√©e."); /* Reset view */ }
             }

            // --- Export Functionality ---
            function exportAnalysis() {
                const notes = analysisNotes.value;
                const analysisName = analysisNameInput.value.trim() || "analyse-coc";
                const fileName = `${analysisName}.png`;

                // Create temporary canvas for export
                const exportCanvas = document.createElement('canvas');
                const exportCtx = exportCanvas.getContext('2d');

                // Calculate height needed for text
                const tempCtxForTextMeasure = document.createElement('canvas').getContext('2d');
                tempCtxForTextMeasure.font = EXPORT_TEXT_FONT;
                const lines = notes.split('\n');
                let textHeight = lines.length * EXPORT_TEXT_LINE_HEIGHT + EXPORT_TEXT_PADDING * 2; // Initial estimate

                // More accurate height calculation needed if wrapping occurs (simplified here)
                // For a proper calculation, we'd need to call wrapText in a dummy mode

                // Set export canvas dimensions
                exportCanvas.width = drawingCanvas.width;
                exportCanvas.height = drawingCanvas.height + textHeight;

                // 1. Fill export canvas with background color
                exportCtx.fillStyle = EXPORT_BG_COLOR;
                exportCtx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);

                // 2. Draw the background canvas content
                exportCtx.drawImage(backgroundCanvas, 0, 0);

                // 3. Draw the drawing canvas content on top
                exportCtx.drawImage(drawingCanvas, 0, 0);

                // 4. Draw the notes text below the image
                exportCtx.fillStyle = '#000000'; // Black text
                exportCtx.font = EXPORT_TEXT_FONT;
                wrapText(exportCtx, notes, EXPORT_TEXT_PADDING, drawingCanvas.height + EXPORT_TEXT_PADDING, exportCanvas.width - EXPORT_TEXT_PADDING * 2, EXPORT_TEXT_LINE_HEIGHT);

                // 5. Trigger download
                const dataUrl = exportCanvas.toDataURL('image/png');
                const link = document.createElement('a');
                link.href = dataUrl;
                link.download = fileName;
                document.body.appendChild(link); // Required for Firefox
                link.click();
                document.body.removeChild(link);

                console.log(`Exported analysis as ${fileName}`);
            }


            // --- Button Event Listeners ---
            toolButtons.forEach(button => {
                button.addEventListener('click', () => {
                    // ... (tool switching logic - same as before) ...
                    const tool = button.getAttribute('data-tool'); currentTool = tool; setActiveButton(toolButtons, button);
                    if (tool === 'marker') { currentMarkerType = button.getAttribute('data-marker'); isMarkerResizable = button.getAttribute('data-resizable') === 'true'; drawingCanvas.style.cursor = isMarkerResizable ? 'crosshair' : 'pointer'; }
                    else { currentMarkerType = ''; isMarkerResizable = false; drawingCanvas.style.cursor = (tool === 'eraser') ? 'cell' : (tool === 'text') ? 'text' : 'crosshair'; }
                    // Reset composite operation when switching tools
                     drawCtx.globalCompositeOperation = 'source-over';
                });
            });

            colorButtons.forEach(button => { /* ... (color switching logic - same as before) ... */
                 button.addEventListener('click', () => { currentColor = button.getAttribute('data-color'); setActiveButton(colorButtons, button); });
            });

            clearCanvasButton.addEventListener('click', () => {
                 if (confirm("Effacer tous les dessins (le fond restera) ?")) { clearDrawingCanvas(); }
            });

            bgImageUpload.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const img = new Image();
                        img.onload = () => {
                             backgroundImage = img; // Store loaded Image object
                             backgroundImageDataUrl = e.target.result; // Store DataURL for saving
                             drawBackground(); // Draw the new background
                             fileNameDisplay.textContent = file.name.length > 30 ? file.name.substring(0, 27) + '...' : file.name;
                        }
                        img.onerror = () => { alert("Erreur chargement image."); backgroundImage = null; backgroundImageDataUrl = null; drawBackground(); fileNameDisplay.textContent = "Erreur"; };
                        img.src = e.target.result;
                    }
                    reader.onerror = () => { alert("Erreur lecture fichier."); };
                    reader.readAsDataURL(file);
                }
                event.target.value = null;
            });

            removeBgButton.addEventListener('click', () => {
                if (confirm("Supprimer l'image de fond ? Les dessins resteront sur fond blanc.")) {
                    backgroundImage = null; backgroundImageDataUrl = null;
                    fileNameDisplay.textContent = "Aucun fichier choisi";
                    drawBackground(); // Redraws the default background
                }
            });

            saveAnalysisButton.addEventListener('click', saveAnalysis);
            savedAnalysesDropdown.addEventListener('change', loadAnalysis);
            deleteAnalysisButton.addEventListener('click', () => { /* ... (delete logic - same as before, ensure it calls saveAnalyses) ... */
                 const selectedName = savedAnalysesDropdown.value; if (!selectedName) { alert("S√©lectionnez une analyse."); return; }
                 if (confirm(`Supprimer "${selectedName}" ?`)) { let analyses = getSavedAnalyses(); analyses = analyses.filter(a => a.name !== selectedName); saveAnalyses(analyses); populateDropdown(); if (analysisNameInput.value === selectedName) { analysisNotes.value = ''; analysisNameInput.value = ''; backgroundImage = null; backgroundImageDataUrl = null; fileNameDisplay.textContent = "Aucun fichier choisi"; resizeCanvas(); clearDrawingCanvas(); } alert(`Analyse "${selectedName}" supprim√©e.`); }
            });
            exportAnalysisButton.addEventListener('click', exportAnalysis);


            // --- Initial App Setup ---
            function initializeApp() {
                 setActiveButton(toolButtons, document.getElementById('toolPencil'));
                 setActiveButton(colorButtons, document.querySelector('.color-btn[data-color="red"]'));
                 populateDropdown(); // Load saved analyses names
                 resizeCanvas(); // Set initial canvas sizes & draw default background
                 deleteAnalysisButton.disabled = savedAnalysesDropdown.options.length <= 1;
                 // Ensure drawing context starts in normal mode
                 drawCtx.globalCompositeOperation = 'source-over';
            }

            // Debounced resize handler
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    console.log("Window resized, adjusting canvas...");
                    // Store overlay before resize potentially clears it
                    const overlayData = drawingCanvas.toDataURL();
                    resizeCanvas(); // Resizes both, redraws background
                    // Restore overlay after resize
                    const img = new Image();
                    img.onload = () => { drawCtx.drawImage(img, 0, 0); };
                    img.src = overlayData;
                }, 250);
            });

            // Canvas Event Listeners (Attached to the TOP canvas: drawingCanvas)
            drawingCanvas.addEventListener('mousedown', handleMouseDown);
            drawingCanvas.addEventListener('mousemove', handleMouseMove);
            drawingCanvas.addEventListener('mouseup', handleMouseUp);
            drawingCanvas.addEventListener('mouseout', () => {
                 if (isDrawing) isDrawing = false;
                 if (isResizingSpell) {
                     if (canvasStateBeforeResize) drawCtx.putImageData(canvasStateBeforeResize, 0, 0); // Restore
                     isResizingSpell = false; canvasStateBeforeResize = null;
                     drawingCanvas.style.cursor = 'crosshair';
                 }
                 // Ensure composite op is reset if mouse leaves during erase
                 drawCtx.globalCompositeOperation = 'source-over';
             });

            initializeApp();

            // Populate dropdown function (needs to be defined before use in init)
             function populateDropdown() { /* ... (same as before) ... */
                const analyses = getSavedAnalyses(); savedAnalysesDropdown.innerHTML = '<option value="">-- S√©lectionnez --</option>'; analyses.sort((a, b) => a.name.localeCompare(b.name)); analyses.forEach(analysis => { const option = document.createElement('option'); option.value = analysis.name; option.textContent = analysis.name; savedAnalysesDropdown.appendChild(option); }); deleteAnalysisButton.disabled = analyses.length === 0 || savedAnalysesDropdown.value === "";
             }
             function getSavedAnalyses() { /* ... (same as before) ... */
                try { const data = localStorage.getItem(STORAGE_KEY); return data ? JSON.parse(data) : []; } catch (e) { console.error("Erreur lecture localStorage:", e); return []; }
             }
             function saveAnalyses(analyses) { /* ... (same as before) ... */
                try { localStorage.setItem(STORAGE_KEY, JSON.stringify(analyses)); } catch (e) { console.error("Erreur sauvegarde localStorage:", e); alert("Erreur sauvegarde. Stockage plein?"); }
             }
             function setActiveButton(buttons, activeButton) { /* ... (same as before) ... */
                buttons.forEach(btn => btn.classList.remove('active')); if (activeButton) { activeButton.classList.add('active'); }
             }

        });
    </script>

</body>
</html>
